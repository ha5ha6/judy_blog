---
layout: single
type: posts
title:  "Topics"
date:   2019-10-25 15:58:25 +0900
related: true
categories: Programming
tags:
  #- Index
  - MinMax
  - Bfs
  - Dfs
  - DP
  - Recursion
  - Topics
  - Hash Table
  - Binary Search
  - N-Sum
author:  Jiexin Wang
classes:  wide
author_profile: true
toc: true
toc_label: "Index"
---

### N Sum  

**leetcode 1 - Two Sum [E] - hash** see [hash table #nsum](https://ha5ha6.github.io/judy_blog/programming/2019/11/14/data-structrue-hash.html#n-sum)  
**leetcode 167 - Two Sum II - Input array is sorted [M] - binary search** see [binary search #twosum](https://ha5ha6.github.io/judy_blog/programming/2019/11/13/algorithm-binarysearch.html#two-sum)  
**leetcode 170 - Two Sum III - Data structure design [E]**  see [design #twosum](https://ha5ha6.github.io/judy_blog/programming/2019/11/15/others-design.html#two-sum)



### Best Time Buy n Sell

**leetcode 121 - Best Time to Buy and Sell Stock (Once) [E] - record min and max**  
Input: [7,1,5,3,6,4]  
Output: 5  
Explanation: Buy on 1 and sell on 6, profit = 6-1 = 5. Not 7-1 = 6, as selling price needs to be larger than buying price.  

Solution 1 - straightforward understandable  

```python      
class Solution1(object):
    def maxProfit(self,prices):
        if not prices:
            return 0

        minp=prices[0]
        maxp=0 #maxprofit
        for p in prices:
            if p<minp:
                minp=p
            elif p-minp>maxp:
                maxp=p-minp

        return maxp
```

Solution 2 - advanced  
minp <- find the min price, and remember it  
maxp <- find the max of p-minp, and remember it  
Input: [7,1,5,3,6,4]  


    (minp,maxp) =  
      (7, 0)  
      (1, 0)  
      (1, 4)  
      (1, 4)  
      (1, 5)  
      (1, 5)  

```python      
class Solution2(object):
    def maxProfit(self,prices):
        minp=float('inf')
        maxp=0
        for p in prices:
            minp=min(p,minp)
            maxp=max(p-minp,maxp)

        return maxp
```

**leetcode 122 - Best Time to Buy and Sell Stock II (Multiple) [E]**  
Input: [7,1,5,3,6,4]  
Output: 7  
Explanation: Buy on 1 and sell on 5, profit = 5-1 = 4. Then buy on 3 and sell on 6, profit = 6-3 = 3.  

```python      
class Solution(object):
    def maxProfit(self,prices):
        res=0
        if not prices:
            return res

        for i in range(len(prices)-1):
            if prices[i]<prices[i+1]:
                res+=prices[i+1]-prices[i]

        return res
```

**leetcode 123 - Best Time to Buy and Sell Stock III (Twice) [H]**  
Input: [3,3,5,0,-1,3,1,4]  
Output: 7  

Solution:  
minp1 <- find the first min price minp1, and remember it  
maxp1 <- find the max of p-minp1, and remember the difference as maxp1  
minp2 <- find the second min price closest to the previous profit: minp2=p-maxp1, and remember it as minp2  
maxp2 <- find the second max of p-minp2, and remember it  


    (minp1,maxp1,minp2,maxp2) =   
          (3, 0, 3, 0)
          (3, 0, 3, 0)
          (3, 2, 3, 2)
          (0, 2, -2, 2)
         (-1, 2, -3, 2)
         (-1, 4, -3, 6)
         (-1, 4, -3, 6)
         (-1, 5, -3, 7)

```python      
class Solution(object):
    def maxProfit(self,prices):
        minp1,minp2=float('inf'),float('inf')
        maxp1,maxp2=0,0
        for p in prices:
            minp1=min(p,minp1)
            maxp1=max(p-minp1,maxp1)
            minp2=min(p-maxp1,minp2)
            maxp2=max(p-minp2,maxp2)

        return maxp2
```

### Word Ladder

**leetcode 127 - Word Ladder [M] (return shortest length) - bfs**  
Example 1:  
Input:  
beginWord = "hit",  
endWord = "cog",  
wordList = ["hot","dot","dog","lot","log","cog"]  
Output: 5  
Explanation: As one shortest transformation is "hit" -> "hot" -> "dot" -> "dog" -> "cog",
return its length 5.  

Example 2:  
Input:   
beginWord = "hit"  
endWord = "cog"  
wordList = ["hot","dot","dog","lot","log"]  
Output: 0  
Explanation: The endWord "cog" is not in wordList, therefore no possible transformation.

Solution:  
1. make a set  
2. put beginWord into bfs (collections.deque)  
3. transform in every char of the word (popleft)  
4. if found valid new word remove it from the set and append it to bfs  

Reference:  
[huahuachan](https://zxi.mytechroad.com/blog/searching/127-word-ladder/)

```python      
class Solution(object):
    def ladderLength(self, beginWord, endWord, wordList):
        wset=set(wordList)
        bfs=collections.deque()
        bfs.append((beginWord,1)) #[(word,length),...]
        while bfs:
            w,l=bfs.popleft()
            if w==endWord:
                return l
            for i in range(len(w)):
                for c in 'abcdefghijklmnopqrstuvwxyz':
                    neww=w[:i]+c+w[i+1:] #transform            
                    if neww in wset and neww!=w:
                        wset.remove(neww)
                        bfs.append((neww,l+1))

        return 0
```

**leetcode 126 - Word Ladder II [H] (return all shortest sequences) - dfs, bidirectional bfs**  
Example:  
Input:  
beginWord = "hit",  
endWord = "cog",  
wordList = ["hot","dot","dog","lot","log","cog"]  
Output:  
[["hit","hot","dot","dog","cog"],  
  ["hit","hot","lot","log","cog"]]  

Solution:  

                  dot -> dog -> cog  
    hit -> hot ->   
                  lot -> log -> cog  

Reference:
[segmentfault](https://segmentfault.com/a/1190000015859013), [huahuachan](https://zxi.mytechroad.com/blog/searching/leetcode-126-word-ladder-ii/)   

### Word Break

**leetcode 139 - Word Break [M] - dp** see [dp #string](https://ha5ha6.github.io/judy_blog/programming/2019/10/23/algorithm-dp.html#dp-string)  
**leetcode 140 - Word Break II [H] - dp + dfs**  
Example 2:  
Input:  
s = "pineapplepenapple"   
wordDict = ["apple", "pen", "applepen", "pine", "pineapple"]  
Output:  
[ "pine apple pen apple",  
  "pine applepen apple",  
  "pineapple pen apple"]  
Explanation: Note that you are allowed to reuse a dictionary word.  

Example 2 Solution:  
1. check if s can be broken into dict words  


         |dfs('pineapplepenapple',dict,'',res)
             |#s[:4]='pine' in dict
             |dfs('applepenapple',dict,'pine ',res)
                 |~s[:5]='apple' in dict
                 |dfs('penapple',dict,'pine apple ',res)
                     |s[:3]='pen' in dict
                     |dfs('apple',dict,'pine apple pen ',res)
                         |s[:5]='apple' in dict
                         |dfs('',dict,'pine apple pen apple',res) <- append res
                 |~s[:8]='applepen' in dict
                 |dfs('apple',dict,'pine applepen ',res)
                     |s[:5]='apple' in dict
                     |dfs('',dict,'pine applepen apple',res) <- append res
             |#s[:9]='pineapple' in dict
             |dfs('penapple',dict,'pineapple ',res)
                 |s[:3]='pen' in dict
                 |dfs('apple',dict,'pineapple pen ',res)
                     |s[:5]='apple' in dict
                     |dfs('',dict,'pineapple pen apple',res) <- append res


```python  
class Solution():
    def wordBreak(self, s, wordDict):
        res = []
        self.dfs(s, wordDict, '', res)
        return res

    def check(self, s, dict):
        dp = [False for i in range(len(s)+1)]
        dp[0] = True
        for i in range(1, len(s)+1):
            for k in range(i):
                if dp[k] and s[k:i] in dict:
                    dp[i] = True
        return dp.pop()

    def dfs(self, s, dict, stringlist, res):
        if self.check(s, dict):
            if not s:
                res.append(stringlist[1:])
            for i in range(1, len(s)+1):
                if s[:i] in dict:
                    self.dfs(s[i:], dict, stringlist+' '+s[:i])
```

### Majority Elements

**leetcode 169 - Majority Element[E]**  
[Hash, Set, Counter, Sort, Randomization, Divide n Conquer, Moore Voting, Bit Manipulation]  

Given an array of size n, find the majority element. The majority element is the element that appears more than ⌊ n/2 ⌋ times.  
Examples:  
Input: [3,2,3]  
Output: 3  
Input: [2,2,1,1,1,2,2]  
Output: 2  

Solution 1 - Brute - Time O(n^2), Space O(1):  

```python  
class Solution():
    def majorityElement(self, nums):
        for n in nums:
            cnt=sum(1 for i in nums if i==n)
            print(n,cnt)
            if cnt>len(nums)//2:
                return n

Output (n,cnt):
2 4
2 4
1 3
1 3
1 3
2 4
2 4
```

Solution 2.1 - Hash - Time O(n):

```python  
class Solution():
    def majorityElement(self, nums):
        cnt={}
        for n in nums:
            if n not in cnt:
                cnt[n]=1
            else:
                cnt[n]+=1
            #or
            #cnt[n] = cnt.get(n, 0) + 1

            if cnt[n]>len(nums)//2:
                return n
```

Solution 2.2 - Hash,Counter - Time O(n), Space O(n):

```python  
class Solution():
    def majorityElement(self, nums):
        cnt=collections.Counter(nums)
        return max(cnt.keys(),key=cnt.get)
```

Solution 3 - Set

```python  
class Solution():
    def majorityElement(self, nums):
        nset=set(nums)
        for n in nset:
            if nums.count(n)>len(nums)//2:
                return n
```

Solution 4 - Sort - Time O(nlogn), Space O(1) or O(n):

```python  
class Solution():
    def majorityElement(self, nums):
        nums.sort()
        return nums[len(nums)//2]
```

Solution 5 - Randomization - Time O(inf):

```python  
import random
class Solution():
    def majorityElement(self, nums):
        while True:
            candidate=random.choice(nums)
            if sum(1 for i in nums if i==candidate)>len(nums)//2:
                return candidate
```

Solution 6 - Divide n Conquer - Time O(nlogn), Space O(logn):  

```python  
class Solution():
    def majorityElement(self, nums):
        return self.dnc(nums,0,len(nums)-1)

    def dnc(self,nums,left,right):
        if left==right:
            return nums[left]

        mid=(left+right)//2
        new_left=self.dnc(nums,left,mid)
        new_right=self.dns(nums,mid+1,right)
        if new_left==new_right:
            return new_left

        return new_left if nums[left:right+1].count(new_left)>nums[left:right+1].count(new_right) else new_right
```

Solution 7 (Best) - Boyer-Moore Voting - Time O(n), Space O(1):

```python
class Solution():
    def majorityElement(self, nums):
        cnt=0
        candidate=None
        for n in nums:
            if cnt==0:
                candidate=n
            cnt+=(1 if n==candidate else -1)

        return candidate
```

Solution 8 - Bit Manipulation: see [ref](https://blog.csdn.net/coder_orz/article/details/51407713)

```python
class Solution():
    def majorityElement(self, nums):
        major=0
        mask=1
        for i in range(0,32):
            cnt=0
            for j in nums:
                if j&mask:
                    cnt+=1
                    if cnt>len(nums)//2:
                        major|=mask
                        break
            mask<<=1

        return major if major>>31==0 else major-(1<<32)
```
