---
layout: single
type: posts
title:  "Topics"
date:   2019-10-25 15:58:25 +0900
related: true
categories: Programming
tags:
  #- Index
  - MinMax
  - Bfs
  - Dfs
  - DP
  - Recursion
  - Topics
  - Hash Table
  - Binary Search
author:  Jiexin Wang
classes:  wide
author_profile: true
toc: true
toc_label: "Index"
---

### N Sum  

**leetcode 1 - Two Sum [E] - hash** see [hash table #nsum](https://ha5ha6.github.io/judy_blog/programming/2019/11/14/data-structrue-hash.html#n-sum)  
**leetcode 167 - Two Sum II - Input array is sorted [M] - binary search** see [binary search #twosum](https://ha5ha6.github.io/judy_blog/programming/2019/11/13/algorithm-binarysearch.html#two-sum)

### Best Time Buy n Sell

**leetcode 121 - Best Time to Buy and Sell Stock (Once) [E] - record min and max**  
Input: [7,1,5,3,6,4]  
Output: 5  
Explanation: Buy on 1 and sell on 6, profit = 6-1 = 5. Not 7-1 = 6, as selling price needs to be larger than buying price.  

Solution 1 - straightforward understandable  

```python      
class Solution1(object):
    def maxProfit(self,prices):
        if not prices:
            return 0

        minp=prices[0]
        maxp=0 #maxprofit
        for p in prices:
            if p<minp:
                minp=p
            elif p-minp>maxp:
                maxp=p-minp

        return maxp
```

Solution 2 - advanced  
minp <- find the min price, and remember it  
maxp <- find the max of p-minp, and remember it  
Input: [7,1,5,3,6,4]  


    (minp,maxp) =  
      (7, 0)  
      (1, 0)  
      (1, 4)  
      (1, 4)  
      (1, 5)  
      (1, 5)  

```python      
class Solution2(object):
    def maxProfit(self,prices):
        minp=float('inf')
        maxp=0
        for p in prices:
            minp=min(p,minp)
            maxp=max(p-minp,maxp)

        return maxp
```

**leetcode 122 - Best Time to Buy and Sell Stock II (Multiple) [E]**  
Input: [7,1,5,3,6,4]  
Output: 7  
Explanation: Buy on 1 and sell on 5, profit = 5-1 = 4. Then buy on 3 and sell on 6, profit = 6-3 = 3.  

```python      
class Solution(object):
    def maxProfit(self,prices):
        res=0
        if not prices:
            return res

        for i in range(len(prices)-1):
            if prices[i]<prices[i+1]:
                res+=prices[i+1]-prices[i]

        return res
```

**leetcode 123 - Best Time to Buy and Sell Stock III (Twice) [H]**  
Input: [3,3,5,0,-1,3,1,4]  
Output: 7  

Solution:  
minp1 <- find the first min price minp1, and remember it  
maxp1 <- find the max of p-minp1, and remember the difference as maxp1  
minp2 <- find the second min price closest to the previous profit: minp2=p-maxp1, and remember it as minp2  
maxp2 <- find the second max of p-minp2, and remember it  


    (minp1,maxp1,minp2,maxp2) =   
          (3, 0, 3, 0)
          (3, 0, 3, 0)
          (3, 2, 3, 2)
          (0, 2, -2, 2)
         (-1, 2, -3, 2)
         (-1, 4, -3, 6)
         (-1, 4, -3, 6)
         (-1, 5, -3, 7)

```python      
class Solution(object):
    def maxProfit(self,prices):
        minp1,minp2=float('inf'),float('inf')
        maxp1,maxp2=0,0
        for p in prices:
            minp1=min(p,minp1)
            maxp1=max(p-minp1,maxp1)
            minp2=min(p-maxp1,minp2)
            maxp2=max(p-minp2,maxp2)

        return maxp2
```

### Word Ladder

**leetcode 127 - Word Ladder [M] (return shortest length) - bfs**  
Example 1:  
Input:  
beginWord = "hit",  
endWord = "cog",  
wordList = ["hot","dot","dog","lot","log","cog"]  
Output: 5  
Explanation: As one shortest transformation is "hit" -> "hot" -> "dot" -> "dog" -> "cog",
return its length 5.  

Example 2:  
Input:   
beginWord = "hit"  
endWord = "cog"  
wordList = ["hot","dot","dog","lot","log"]  
Output: 0  
Explanation: The endWord "cog" is not in wordList, therefore no possible transformation.

Solution:  
1. make a set  
2. put beginWord into bfs (collections.deque)  
3. transform in every char of the word (popleft)  
4. if found valid new word remove it from the set and append it to bfs  

Reference:  
[huahuachan](https://zxi.mytechroad.com/blog/searching/127-word-ladder/)

```python      
class Solution(object):
    def ladderLength(self, beginWord, endWord, wordList):
        wset=set(wordList)
        bfs=collections.deque()
        bfs.append((beginWord,1)) #[(word,length),...]
        while bfs:
            w,l=bfs.popleft()
            if w==endWord:
                return l
            for i in range(len(w)):
                for c in 'abcdefghijklmnopqrstuvwxyz':
                    neww=w[:i]+c+w[i+1:] #transform            
                    if neww in wset and neww!=w:
                        wset.remove(neww)
                        bfs.append((neww,l+1))

        return 0
```

**leetcode 126 - Word Ladder II [H] (return all shortest sequences) - dfs, bidirectional bfs**  
Example:  
Input:  
beginWord = "hit",  
endWord = "cog",  
wordList = ["hot","dot","dog","lot","log","cog"]  
Output:  
[["hit","hot","dot","dog","cog"],  
  ["hit","hot","lot","log","cog"]]  

Solution:  

                  dot -> dog -> cog  
    hit -> hot ->   
                  lot -> log -> cog  

Reference:
[segmentfault](https://segmentfault.com/a/1190000015859013), [huahuachan](https://zxi.mytechroad.com/blog/searching/leetcode-126-word-ladder-ii/)   

### Word Break

**leetcode 139 - Word Break [M] - dp** see [dp #string](https://ha5ha6.github.io/judy_blog/programming/2019/10/23/algorithm-dp.html#dp-string)  
**leetcode 140 - Word Break II [H] - dp + dfs**  
Example 2:  
Input:  
s = "pineapplepenapple"   
wordDict = ["apple", "pen", "applepen", "pine", "pineapple"]  
Output:  
[ "pine apple pen apple",  
  "pine applepen apple",  
  "pineapple pen apple"]  
Explanation: Note that you are allowed to reuse a dictionary word.  

Example 2 Solution:  
1. check if s can be broken into dict words  


         |dfs('pineapplepenapple',dict,'',res)
             |#s[:4]='pine' in dict
             |dfs('applepenapple',dict,'pine ',res)
                 |~s[:5]='apple' in dict
                 |dfs('penapple',dict,'pine apple ',res)
                     |s[:3]='pen' in dict
                     |dfs('apple',dict,'pine apple pen ',res)
                         |s[:5]='apple' in dict
                         |dfs('',dict,'pine apple pen apple',res) <- append res
                 |~s[:8]='applepen' in dict
                 |dfs('apple',dict,'pine applepen ',res)
                     |s[:5]='apple' in dict
                     |dfs('',dict,'pine applepen apple',res) <- append res
             |#s[:9]='pineapple' in dict
             |dfs('penapple',dict,'pineapple ',res)
                 |s[:3]='pen' in dict
                 |dfs('apple',dict,'pineapple pen ',res)
                     |s[:5]='apple' in dict
                     |dfs('',dict,'pineapple pen apple',res) <- append res


```python  
class Solution():
    def wordBreak(self, s, wordDict):
        res = []
        self.dfs(s, wordDict, '', res)
        return res

    def check(self, s, dict):
        dp = [False for i in range(len(s)+1)]
        dp[0] = True
        for i in range(1, len(s)+1):
            for k in range(i):
                if dp[k] and s[k:i] in dict:
                    dp[i] = True
        return dp.pop()

    def dfs(self, s, dict, stringlist, res):
        if self.check(s, dict):
            if not s:
                res.append(stringlist[1:])
            for i in range(1, len(s)+1):
                if s[:i] in dict:
                    self.dfs(s[i:], dict, stringlist+' '+s[:i])
```

### Majority Elements

[Hash, Set, Counter, Sort, Randomization, Divide n Conquer, Moore Voting, Bit Manipulation]
